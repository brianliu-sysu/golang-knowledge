# **GMP 调度模型**

GMP 是 Go 语言的协程调度模型，旨在为开发者提供高效、便捷的并发编程能力，通过用户态调度实现轻量级协程的管理。

---

## **核心组件**

- **G (Goroutine)**：协程，代表一个待执行的任务单元，是 Go 并发的基本执行体
- **M (Machine)**：操作系统线程，是任务的实际执行者，负责运行 G
- **P (Processor)**：逻辑处理器，是 G 和 M 之间的调度器，维护本地可运行的 G 队列。只有当 P 与 M 绑定时，M 才能执行 G

---

## **调度流程**

### **1. 初始化阶段**
- 运行时根据宿主机 CPU 核心数创建相应数量的 P（可通过 `GOMAXPROCS` 手动指定）
- 每个 P 维护一个本地 G 队列，用于存储待执行的协程

### **2. 绑定与执行**
- P 寻找空闲的 M 进行绑定；若无空闲 M，则创建新的 M
- 绑定成功后，M 开始执行 P 本地队列中的 G

### **3. 用户态阻塞处理**
当 G 因以下原因阻塞时，M 不会被阻塞：
- **网络 I/O**
- **Channel 操作**
- **锁等待**

**处理机制**：M 将 G 标记为等待状态并加入相应的等待队列（如 netpoller），然后立即执行其他可运行的 G

### **4. 系统调用阻塞处理**
当 G 执行系统调用（如文件 I/O）导致 M 阻塞时：
- M 进入 **syscall** 状态
- **切换机制**：经过约 10ms 后，P 与当前 M 解绑，寻找或创建新的 M 继续执行其他 G
- 系统调用完成后，原 M 恢复并尝试获取空闲 P；若无可用 P，则将 G 放入全局队列，M 进入空闲状态

---

## **工作窃取机制 (Work Stealing)**

### **任务分配策略**
1. **本地优先**：新创建的 G 优先放入当前 P 的本地队列
2. **本地队列溢出**：当本地队列已满时，取本地队列的一半 G 连同新 G 一起放入全局队列

### **任务获取策略**
1. **定期检查全局队列**：每个 P 每执行 61 次调度会检查一次全局队列，防止全局任务饥饿
2. **本地队列为空时**：
   - 首先从全局队列获取 G
   - 若全局队列为空，则随机选择其他 P，窃取其本地队列约一半的任务
3. **自旋状态**：若所有队列都为空，M 进入 **spinning** 状态主动寻找任务，最多允许 `GOMAXPROCS` 个 M 处于 spinning 状态，其余 M 进入空闲队列

---

## **抢占式调度**

### **设计目标**
防止单个协程长时间占用 CPU，保证调度公平性，避免协程饥饿

### **时间片限制**
每个 G 的连续执行时间上限为 **10ms**

### **抢占机制演进**

#### **早期方案：协作式抢占（Go 1.2-1.13）**
- 在函数调用入口插入抢占检查点
- **局限性**：无法抢占处于紧密循环或无函数调用的 G（如 `for {}` 死循环）

#### **现代方案：基于信号的异步抢占（Go 1.14+）**
- 使用操作系统信号（如 `SIGURG`）实现真正的异步抢占
- 调度器向目标 M 发送信号，强制中断当前 G 的执行
- **优势**：可抢占任意执行状态的 G，包括纯计算密集型任务
